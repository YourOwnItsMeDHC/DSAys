/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

// Reverse LL usng recursion - 
// https://github.com/YourOwnItsMeDHC/DSAys/commit/ea72cac2a1aeaee3740b4e0993ea9d2a19bcc17e

// Aproach - 01 : Iterative
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;   // Initialize prev to null
        ListNode curr = head;   // Initialize curr to head

        // Iterate through the list
        while (curr != null) {
            ListNode nextTemp = curr.next; // Store the next node
            // Here, we are reversing the LL, hence previous will be the next of the cuurent node
            curr.next = prev;              // Reverse the current node's pointer
            prev = curr;                   // Move prev to the current node
            curr = nextTemp;               // Move to the next node
        }

        return prev; // prev is the new head of the reversed list
    }
}




// Dry Run with Linked List 1 -> 2 -> 3 -> 4 -> 5

// Initial State

// prev = null
// curr = 1 -> 2 -> 3 -> 4 -> 5

// Iteration 1

// nextTemp = 2 -> 3 -> 4 -> 5 (store the next node)
// curr.next = prev (reverse the link, 1 -> null)
// prev = 1 -> null
// curr = 2 -> 3 -> 4 -> 5
// State after Iteration 1
// prev = 1 -> null
// curr = 2 -> 3 -> 4 -> 5

// Iteration 2

// nextTemp = 3 -> 4 -> 5 (store the next node)
// curr.next = prev (reverse the link, 2 -> 1 -> null)
// prev = 2 -> 1 -> null
// curr = 3 -> 4 -> 5
// State after Iteration 2
// prev = 2 -> 1 -> null
// curr = 3 -> 4 -> 5

// Iteration 3

// nextTemp = 4 -> 5 (store the next node)
// curr.next = prev (reverse the link, 3 -> 2 -> 1 -> null)
// prev = 3 -> 2 -> 1 -> null
// curr = 4 -> 5
// State after Iteration 3
// prev = 3 -> 2 -> 1 -> null
// curr = 4 -> 5

// Iteration 4

// nextTemp = 5 (store the next node)
// curr.next = prev (reverse the link, 4 -> 3 -> 2 -> 1 -> null)
// prev = 4 -> 3 -> 2 -> 1 -> null
// curr = 5
// State after Iteration 4
// prev = 4 -> 3 -> 2 -> 1 -> null
// curr = 5

// Iteration 5

// nextTemp = null (store the next node)
// curr.next = prev (reverse the link, 5 -> 4 -> 3 -> 2 -> 1 -> null)
// prev = 5 -> 4 -> 3 -> 2 -> 1 -> null
// curr = null (end of the list)

// Final State

// prev = 5 -> 4 -> 3 -> 2 -> 1 -> null (new head of the reversed list)
// curr = null (end of the list)

// The loop terminates when curr becomes null.
// At this point, prev points to the head of the reversed linked list.
// Thus, the reversed linked list is 5 -> 4 -> 3 -> 2 -> 1.






















// Aproach - 02 : Recursive
class Solution {
    public ListNode reverseList(ListNode head) {
        // Base case: if head is null or only one node, return head
        if (head == null || head.next == null) {
            return head;
        }
        
        // Recursively reverse the rest of the list
        ListNode newHead = reverseList(head.next);
        
        // Adjust the pointers
        head.next.next = head;  // The next node's next pointer should point to the current node
        head.next = null;       // Set the current node's next pointer to null
        
        return newHead;  // Return the new head of the reversed list
    }
}


// Recursive Approach with Explanation
// Key Concepts:

// Base Case:
// When the recursion reaches the end of the list (i.e., the last node),
// this node becomes the new head of the reversed list.

// Recursive Step:
// For each recursive call, we reverse the pointers for the current node.

// Steps:

// Base Case:
// If the head is null or head.next is null, return head.
// This means we've reached the end of the list or the list is empty.

// Recursive Call:
// Recursively call the function on the next node to reverse the rest of the list.

// Adjust Pointers:
// After reversing the rest of the list, we need to adjust the pointers so that the next node's next pointer points to the current node, effectively reversing the link between these two nodes. Then set the current node's next pointer to null to indicate the end of the reversed list.

// Detailed Steps:

// Recursive Call: ListNode newHead = reverseList(head.next);

// This call will continue until the end of the list is reached.

// Adjust Pointers:

// head.next.next = head;:

// head.next is the next node.
// head.next.next is the next node's next pointer.
// Setting head.next.next = head makes the next node point back to the current
// node, effectively reversing the link.

// head.next = null;:

// This is necessary to avoid cycles. It sets the current node's next pointer to
// null, indicating the end of the reversed portion of the list.
// Return New Head: Return newHead, which is the head of the fully reversed list.





// Dry Run:

// Input List: 1 -> 2 -> 3 -> 4 -> 5

// Recursive calls and pointer adjustments:

// reverseList(1 -> 2 -> 3 -> 4 -> 5)
// reverseList(2 -> 3 -> 4 -> 5)
// reverseList(3 -> 4 -> 5)
// reverseList(4 -> 5)
// reverseList(5) (base case, return 5)

// Adjust pointers in reverse order of calls:

// For head = 4:
// 4.next is 5
// 5.next = 4 (now 5 points to 4)
// 4.next = null (break the link to avoid cycle)

// For head = 3:
// 3.next is 4
// 4.next = 3 (now 4 points to 3)
// 3.next = null

// For head = 2:
// 2.next is 3
// 3.next = 2 (now 3 points to 2)
// 2.next = null

// For head = 1:
// 1.next is 2
// 2.next = 1 (now 2 points to 1)
// 1.next = null

// Output List: 5 -> 4 -> 3 -> 2 -> 1